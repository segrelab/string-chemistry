'''
Given a list of characters to use as monomers and a max polymer length,
create a network of all possible reactions.
'''

import itertools as it
import numpy as np
import random
import cobra
import re
#import pygraphviz as gv

class CreateNetwork():
    # given a set of monomers and a max polymer length, generate a network
    def __init__(self, monos, max_len, no_mirrors = False, make_stoich = False):
        '''
        Given a set of monomers and a maximum polymer length, generate all
        possible string chemicals subject to those constraints as well as all
        binary fusion and fission reactions involving those metabolites.

        If no_mirrors is True, will check metabolites list for metabolites that
        are mirror images of each other and remove duplicates. Noticeably
        increases runtime.

        If make_stoich is True, will save the stoichiometric matrix
        corresponding to this network as a numpy array. Noticeably increases
        memory required to run.
        '''
        self.met_list = self.make_met_list(monos, max_len, no_mirrors)
        self.met_set = set(self.met_list)
        self.rxn_list = self.make_rxn_list(self.met_list, no_mirrors)
        if make_stoich is True:
            self.S = self.make_stoich_mat(self.rxn_list, self.met_list)

    def remove_mirrors(self, with_mirrors):
        '''
        Given a list of metabolites that contains mirror-image duplicates, 
        identify all such duplicates and remove them.
        E.g. if the list includes both 'aab' and 'baa', only keep one
        '''
        no_mirrors = set()
        for item in with_mirrors:
            if item[::-1] not in no_mirrors:
                no_mirrors.add(item)
        return(no_mirrors)

    def make_met_list(self, monos, max_len, no_mirrors):
        '''
        Given a list of monomers and a maximum polymer length, make a list of
        all possible string chemicals satisfying those constraints
        '''
        # use itertools.product to get all possible combinations of the
        # characters in monos up to length i, then do that for every length i
        # from 1 to max_len. itertools.product returns tuples, hence the
        # coercion and joining
        met_list = list()
        if no_mirrors is True:
            met_list = [
                ''.join(list(t))
                for i in range(1, max_len+1)
                for t in self.remove_mirrors(it.product(monos, repeat = i))
            ]
        elif no_mirrors is False:
            met_list = [
                ''.join(list(t))
                for i in range(1,max_len+1)
                for t in it.product(monos, repeat = i)
            ]
        return(met_list)

    def make_rxns1(self, met):
        '''
        Given a metabolite, find all pairs of smaller metabolites that can be
        generated by splitting the given metabolite into two pieces
        '''
        rxn_set = set()
        if len(met) > 1:
            for i in range(1, len(met)):
                start = met[0:i]
                end = met[i:]
                rxn = f'{met}->{start}+{end}'
                # make sure the same reaction with products in the opposite
                # order isn't already in the reactions list
                rev_rxn = f'{met}->{end}+{start}'
                if rev_rxn in rxn_set:
                    pass
                else:
                    rxn_set.add(rxn)
        rxn_list = list(rxn_set)
        return(rxn_list)

    def make_rxns2(self, met):
        '''
        Given a metabolite, find all pairs of smaller metabolites that can be
        geerated by splitting the given metabolite into two pieces and ensure
        that the two pieces are not mirror images of each other
        '''
        rxn_set = set()
        if len(met) > 1:
            for i in range(1, len(met)):
                start = met[0:i]
                end = met[i:]
                # make sure that all the metabolites we generate are in met_list
                # which may require reversing them since we only kept one of the
                # two possible orderings of each metabolite
                if start not in self.met_set:
                    start = start[::-1]
                if end not in self.met_set:
                    end = end[::-1]
                rxn = f'{met}->{start}+{end}'
                # make sure the same reaction with products in the opposite
                # order isn't already in the reactions list
                rev_rxn = f'{met}->{end}+{start}'
                if rev_rxn in rxn_set:
                    pass
                else:
                    rxn_set.add(rxn)
        rxn_list = list(rxn_set)
        return(rxn_list)

    # find all decomposition reactions for all metabolites
    # only considering mono/bimolecular breakdowns because irl we know higher
    # molecularity reactions tend not to happen
    def make_rxn_list(self, met_list, no_mirrors):
        '''
        Given a list of metabolites, identify all ways to split each metabolite
        into two smaller metabolites. If no_mirrors is True, only includes 
        reactions that produce metabolites that are not mirror images of each
        other
        '''
        rxn_list = list()
        if no_mirrors is True:
            # get a list of lists from map so need to flatten
            rxn_list = [
                x for y in list(map(self.make_rxns2, met_list)) for x in y
            ]
        elif no_mirrors is False:
            # get a list of lists from map so need to flatten
            rxn_list = [
                x for y in list(map(self.make_rxns1, met_list)) for x in y
            ]
        return(rxn_list)

    def make_stoich_mat(self, rxn_list, met_list):
        '''
        Given a list of reactions, make a stoichiometric matrix with one column
        for each metabolite and one row for each reaction and appropriate
        stoichiometric coefficients in the cells
        Can take a long time and a lot of memory to create for networks larger
        than ~20,000 reactions. Because of this potentially high memory
        requirement, saves the matrix as a numpy memory map
        '''
        # since these can get very large, we need to use a memory-mapped object
        #print(f'Dimensions of matrix: {len(rxn_list)}, {len(met_list)}')
        S = np.memmap('stoich_mat.dat', dtype = np.float32, mode = 'w+',
            shape = (len(rxn_list), len(met_list)))
        # fill the array with 0s
        for i in range(0, len(met_list)):
            S[:,i] = np.zeros(len(rxn_list))
        # for each reaction, change all the appropriate zeros to actual numbers
        for i in range(0, len(rxn_list)):
            # technically we don't need to make all these variables but giving
            # things names makes this significantly more legible imo
            ref_rxn = rxn_list[i]
            bits = ref_rxn.split('->')
            reacs = bits[0].split('+')
            prods = bits[1].split('+')
            # find the indices for each of these substances in met_list so we
            # edit the appropriate column in S
            for met in reacs:
                S[i,met_list.index(met)] = -1
            for met in prods:
                # add 1 instead of assigning 1 in case two products are
                # the same, e.g. 'adad -> ad + ad'
                S[i,met_list.index(met)] += 1.0
        return(S)

def make_edgelist(rxn_list, rxns_as_nodes = True):
    '''
    Given a list of reactions, make a list of edges in the corresponding
    metabolic network to facilitate visualization of the network
    '''
    # start by making a dictionary to look up species involved in a reaction
    # using the string notation of that reaction
    rxn_dict = dict()
    for rxn in rxn_list:
        rxn_dict[rxn] = re.split('(\+|\-\>)', rxn)[0::2]
    edgelist = []
    if rxns_as_nodes is True:
        for rxn in rxn_list:
            # could use less code but this is easier to interpret for humans
            reac = rxn_dict[rxn][0]
            prod1 = rxn_dict[rxn][1]
            prod2 = rxn_dict[rxn][2]
            # put reaction after reactant and before product in case you want a
            # directed graph
            edgelist.append((reac, rxn))
            edgelist.append((rxn, prod1))
            # presumably, most of the time you don't want duplicate edges
            if prod1 != prod2:
                edgelist.append((rxn, prod2))
    elif rxns_as_nodes is False:
        for rxn in rxn_list:
            # could use less code but this is easier to interpret for humans
            reac = rxn_dict[rxn][0]
            prod1 = rxn_dict[rxn][1]
            prod2 = rxn_dict[rxn][2]
            edgelist.append((reac, prod1))
            edgelist.append((reac, prod2))
    return(edgelist)

def remove_random_rxns(more_rxns, S, prob):
    '''
    Given a list of reactions, a stoichiometric matrix and a probability
    between 0 and 1, loop over the list of reactions and remove reactions
    according to the given probability
    '''
    # randomly pick reactions to remove
    to_remove = []
    for rxn in more_rxns:
        if random.random() < prob:
            to_remove.append(rxn)
        else:
            pass
    # remove those reactions from the reaction list and stoichiometric matrix
    less_rxns = [x for x in more_rxns if x not in to_remove]
    # indices in more_rxns are the row indices of S
    indices = [more_rxns.index(x) for x in less_rxns]
    smaller_S = S[indices,]
    return(less_rxns, smaller_S)

def make_cobra_model(met_list, rxn_list, allow_export = True):
    '''
    Given a list of metabolites and reactions, make a COBRApy model 
    representing the corresponding metabolic network
    If allow_export is True, an extra reaction will be added for every
    metabolite that consumes the metabolite and produces nothing to simulate
    secretion of waste products
    '''
    model = cobra.Model('string_chem')
    # start with the metabolites
    # we will need to make a dictionary with the COBRA metabolite objects
    # as keys and stoichiometric coefficients as values, so we'll need a way
    # to look up the COBRA metabolite objects using their names, since
    cobra_mets = [cobra.Metabolite(met, compartment = 'c') for met in met_list]
    met_dict = dict()
    for met in met_list:
        met_dict[met] = cobra.Metabolite(met, compartment = 'c')
    
    # start working on the reactions
    # start by making a dictionary to look up species involved in a reaction
    # using the string notation of that reaction
    rxn_dict = dict()
    for rxn in rxn_list:
        rxn_dict[rxn] = re.split('(\+|\-\>)', rxn)[0::2]

    # start by just making the COBRA reaction objects then add metabolites
    cobra_rxns = [
        # make all reactions reversible by default
        cobra.Reaction(rxn, upper_bound = 1000.0, lower_bound = -1000.0)
        for rxn in rxn_list
    ]
    for rxn in cobra_rxns:
        # find all the COBRA metabolites associated with this reaction
        c_mets = [met_dict[met] for met in rxn_dict[rxn.id]]
        # we know the first metabolite in the list is the reactant
        rxn.add_metabolites({c_mets[0] : -1.0})
        # check if reactant splits into two identical products
        if rxn_dict[rxn.id][1] == rxn_dict[rxn.id][2]:
            rxn.add_metabolites({c_mets[1] : 2.0})
        else:
            rxn.add_metabolites({c_mets[1] : 1.0, c_mets[2] : 1.0})
        # now that the reaction is complete, we can just add it to the model
        model.add_reaction(rxn)

    # add in export reactions for all metabolites if specified
    if allow_export is True:
        for met in cobra_mets:
            out_rxn = cobra.Reaction(
                met.id + '->',
                upper_bound = 1000.0, # only allow exporting
                lower_bound = 0.0
            )
            out_rxn.add_metabolites({met: -1.0})
            model.add_reaction(out_rxn)
    return(model)

def choose_inputs(n, model, bm_rxn=cobra.Reaction()):
    '''
    Choose n random metabolites to get exchange reactions that produce them
    from nothing to simulate food/nutrient uptake reactions
    '''
    # make sure we don't choose any metabolites in the biomass reaction but
    # also set an empty reaction as the default biomass reaction just in case
    # we're setting food sources before biomass precursors
    in_mets = random.sample(
        [met for met in model.metabolites if met not in bm_rxn.metabolites],
        n
    )
    for met in in_mets:
        in_rxn = cobra.Reaction(
            '->' + met.id,
            upper_bound = 100.0, # only allow importing of this metabolite
            lower_bound = 0.0
        )
        in_rxn.add_metabolites({met: 1.0})
        model.add_reaction(in_rxn)
    # all of these modifications are happening in-place, so we don't need to
    # return the network
    return(None)

def choose_bm_mets(n, model):
    '''
    Choose n random metabolites to create a reaction that consumes all of them
    in equal proportions and produces nothing (simulates biomass production)
    '''
    # make sure no metabolite is both an input and biomass metabolite; start by
    # getting a list of all the metabolites that are already in boundary
    # reactions
    boundary_mets = [rxn.metabolites for rxn in model.boundary]
    bm_mets = random.sample(
        [met for met in model.metabolites if met not in boundary_mets], n
    )
    bm_rxn = cobra.Reaction(
        '+'.join([met.id for met in bm_mets]) + '->',
        upper_bound = 1000.0,
        lower_bound = 0
    )
    for met in bm_mets:
        bm_rxn.add_metabolites({met:-1.0})
    model.add_reaction(bm_rxn)
    # the model object is modified in-place, so there's no need to return it
    return(bm_rxn)

def min_flux_prune(cobra_model, bm_rxn):
    '''
    Iteratively remove reactions from the network by identifying reactions with
    the smallest flux until removing a reaction causes biomass flux to drop to
    zero
    '''
    # removing reactions happens in-place, so we need to make a copy of the 
    # cobra model before altering it in any way
    cobra_net = cobra_model.copy()
    # assign reaction fluxes to everything before starting the loop
    solution = cobra_net.optimize()
    bm_rxn_flux = solution.fluxes.get(key = bm_rxn.id)
    while True:
        # remove all non-boundary reactions with no flux
        no_flux_rxn_ids = solution.fluxes[solution.fluxes == 0].index
        boundary_rxn_ids = [rxn.id for rxn in cobra_net.boundary]
        ids_to_remove = [
            rxn for rxn in no_flux_rxn_ids if rxn not in boundary_rxn_ids
        ]
        rxns_to_remove = [
            cobra_net.reactions.get_by_id(rxn_id) for rxn_id in ids_to_remove
        ]
        cobra_net.remove_reactions(rxns_to_remove)
        # find remaining reaction with smallest flux and remove it
        flux_bearers = solution.fluxes[solution.fluxes != 0]
        min_flux_rxn_id = flux_bearers.abs().idxmin()
        min_flux_rxn = cobra_net.reactions.get_by_id(min_flux_rxn_id)
        # if this reaction is the biomass reaction, we're clearly done pruning
        if min_flux_rxn.id == bm_rxn.id:
            break
        cobra_net.remove_reactions([min_flux_rxn])
        # see if that made the network unsolvable; if so, add the reaction back
        # and exit the while loop
        solution = cobra_net.optimize()
        # sometimes the solution will be feasible but the flux through the
        # biomass reaction will be some absurdly small number and then if you
        # do FBA on the same network again you won't get a feasible solution
        # so can't just check to see if the flux is 0
        bm_rxn_flux = solution.fluxes.get(key = bm_rxn.id)
        if solution.status == 'infeasible' or bm_rxn_flux < 10e-10:
            cobra_net.add_reaction(min_flux_rxn)
            break
    # we kept all of the boundary reactions around until now; drop the ones
    # that have no flux
    # have to recreate the solution object first since we probably just added
    # an essential reaction back to the network after discovering that it was
    # essential
    solution = cobra_net.optimize()
    cobra_net.remove_reactions(solution.fluxes[solution.fluxes == 0].index)
    return(cobra_net)

def random_prune(full_model, bm_rxn):
    '''
    Remove all reactions from a given network with no flux, randomly choose one
    of the remaining reactions to remove and repeat those steps until removing
    any reaction from the network would make flux through the biomass reaction
    impossible
    '''
    # removing reactions happens in-place, so we need to make a copy of the
    # cobra model before altering it in any way
    pruned_model = full_model.copy()
    # start by doing FBA and removing all reactions with no flux that are
    # not an export reaction
    solution = pruned_model.optimize()
    no_flux_rxn_ids = solution.fluxes[solution.fluxes == 0].index
    export_rxn_ids = [
        rxn.id for rxn in pruned_model.boundary if rxn.id.endswith('->')
    ]
    rxns_to_remove = [
        rxn for rxn in no_flux_rxn_ids if rxn not in export_rxn_ids
    ]
    pruned_model.remove_reactions(rxns_to_remove)
    # get a list of all the reaction ids we didn't just remove to loop over
    # as we try to remove reactions
    flux_bearer_names = solution.fluxes[solution.fluxes != 0].index
    # exclude the biomass reaction, since we know we want to keep that
    flux_bearers = [
        rxn for rxn in pruned_model.reactions 
        if rxn.id in flux_bearer_names and rxn.id != bm_rxn.id
    ]
    # shuffle this list and then do a for loop over it so that we can tell if
    # we tried to remove every single possible reaction and failed (i.e. we are
    # done pruning); if we randomly chose from the list, we wouldn't ever know
    # that we actually tried every single reaction in the list, and we would
    # probably needlessly try the same reaction multiple times
    random.shuffle(flux_bearers)
    # if this ever reaches the length of flux_bearers, we are done pruning
    infeas_count = 0
    while infeas_count < len(flux_bearers):
        for rxn in flux_bearers:
            # try to remove the reaction from the model
            pruned_model.remove_reactions([rxn])
            # see if there's still a way to get flux through the biomass rxn
            solution = pruned_model.optimize()
            # sometimes "feasible" solutions have extremely small fluxes
            # through the biomass reaction
            bm_rxn_flux = solution.fluxes.get(key = bm_rxn.id)
            if solution.status == 'infeasible' or bm_rxn_flux < 10e-10:
                # keep track of how many times we've gotten a bad solution
                infeas_count += 1
                # put this reaction back and get the old solution object back
                pruned_model.add_reaction(rxn)
                solution = pruned_model.optimize()
            else:
                # remove all non-export reactions with no flux
                no_flux_rxn_ids = solution.fluxes[solution.fluxes == 0].index
                export_rxn_ids = [
                    rxn.id for rxn in pruned_model.boundary 
                    if rxn.id.endswith('->')
                ]
                rxns_to_remove = [
                    rxn for rxn in no_flux_rxn_ids if rxn not in export_rxn_ids
                ]
                pruned_model.remove_reactions(rxns_to_remove)
                # recreate the list of non-biomass reaction flux bearers
                flux_bearer_names = solution.fluxes[solution.fluxes != 0].index
                flux_bearers = [
                    rxn for rxn in pruned_model.reactions
                    if rxn.id in flux_bearer_names and rxn.id != bm_rxn.id
                ]
                # reset infeas_count
                infeas_count = 0
                break
    # we kept the exchange reactions around to make sure waste could be
    # exported if needed but now they can all be dropped
    pruned_model.remove_reactions(solution.fluxes[solution.fluxes == 0].index)
    return(pruned_model)

def make_rxn_incl(full_model, pruned_model):
    '''
    Given two networks where one is a subnetwork (pruned_model) of the other
    (full_model), make a vector of 1s and 0s where 1s indicate reactions
    present in both networks. The order of entries corresponds to the order of
    reactions in full_model, so if you call this several times with different
    networks pruned from the same full_model, you can directly compare the
    output vectors
    '''
    # make sure the pruned network is actually a subnetwork of the full one
    for rxn in pruned_model.reactions:
        if rxn not in full_model.reactions:
            raise Exception(
                'Could not construct bitstrings because second network was ' +
                'not a subnetwork of the full network.\n' +
                f'Problematic reaction: {rxn.id}')
    all_reactions = full_model.reactions
    # make sure the reactions are in the same order so we can directly compare
    # multiple bitstrings from multiple different networks derived from the
    # same parent network
    all_reactions.sort()
    bits = [1 if rxn in pruned_model.reactions else 0 for rxn in all_reactions]
    rxn_incl = ''.join([str(bit) for bit in bits])
    return(rxn_incl)

def viz_universal_net(full_model, bm_rxn, show_all = False):
    '''
    Use pygraphviz to visualize a string chemistry network
    show_all governs whether or not every reaction and metabolite are shown; if
    false, only the reactions and metabolites that actually carry flux in the
    supplied COBRA model will be visualized
    '''
    # make a graphviz object
    full_graph = gv.AGraph(
        size = '5,5', 
        dpi = '400', 
        splines = 'true', # this API was made perfectly and intuitively
        directed = True,
    )
    # distinguish metabolite and reaction nodes by shape
    for met in full_model.metabolites:
        # grey out metabolites that aren't produced or consumed by anything if
        # show_all is True or just skip them if it's False
        if all([abs(rxn.flux) < 0.01 for rxn in met.reactions]):
            if show_all:
                full_graph.add_node(met.id, shape = 'box', color = 'grey')
            else:
                pass
        # make other metabolite nodes blue
        else:
            full_graph.add_node(met.id, shape = 'box', color = 'blue')
    for rxn in full_model.reactions:
        # reactions with no flux get grey nodes if show_all is True and get
        # completely whited out if it's false (so that all the nodes are still
        # there but invisible)
        if abs(rxn.flux) < 0.01:
            if show_all:
                full_graph.add_node(rxn.id, shape = 'oval', color = 'grey')
            else:
                full_graph.add_node(
                    rxn.id,
                    shape = 'oval',
                    color = 'invis',
                    fontcolor = 'invis'
                )
        # nodes for reactions with flux are red
        else:
            full_graph.add_node(rxn.id, shape = 'oval', color = 'red')
        # now handle edges
        if abs(rxn.flux) < 10e-10:
            # reactions with no flux get grey edges if show_all is True and get
            # added invisibly (i.e. everything about them is white) if show_all
            # is false
            if show_all:
                for met in rxn.metabolites:
                    # direct edges based on stoichiometric coefficients
                    if rxn.metabolites[met] > 0:
                        # products
                        full_graph.add_edge([rxn.id, met.id], color = 'grey')
                    else:
                        # reactants
                        full_graph.add_edge([met.id, rxn.id], color = 'grey')
            else:
                for met in rxn.metabolites:
                    if rxn.metabolites[met] > 0:
                        # products
                        full_graph.add_edge(
                            [rxn.id, met.id],
                            color = 'invis',
                            fontcolor = 'invis'
                        )
                    else:
                        # reactants
                        full_graph.add_edge(
                            [met.id, rxn.id],
                            color = 'invis',
                            fontcolor = 'invis'
                        )
        else:
            # exchange reactions get green edges
            if rxn == bm_rxn or rxn in full_model.boundary:
                for met in rxn.metabolites:
                    # direct edges based on stoichiometric coefficients
                    # all exchange reactions are initialized so they can only
                    # proceed in the forward direction, so we don't have to
                    # worry about the sign of the flux
                    if rxn.metabolites[met] > 0:
                        # products
                        full_graph.add_edge(
                            [rxn.id, met.id], color = 'green'
                        )
                    else:
                        # reactants
                        full_graph.add_edge(
                            [met.id, rxn.id], color = 'green'
                        )
            # other reactions get thicker black edges
            else:
                for met in rxn.metabolites:
                    # have to use both stoichiometric coefficients and the sign
                    # of the flux to direct edges for these reactions, since 
                    # they have every right to be negative
                    if rxn.flux > 0:
                        # reaction is in the forward direction
                        if rxn.metabolites[met] > 0:
                            # prodcuts
                            full_graph.add_edge(
                                [rxn.id, met.id], penwidth = 2
                            )
                        else:
                            # reactants
                            full_graph.add_edge(
                                [met.id, rxn.id], penwidth = 2
                            )
                    else:
                        # reaction is running in the reverse direction, so 
                        # invert signs on stoichiometric coefficients
                        if rxn.metabolites[met] > 0:
                            # reactants
                            full_graph.add_edge(
                                [met.id, rxn.id], penwidth = 2
                            )
                        else:
                            # products
                            full_graph.add_edge(
                                [rxn.id, met.id], penwidth = 2
                            )
    # return the graph without setting a layout or drawing it so that can be
    # handeled in whatever way fits the context
    return(full_graph)

def viz_pruned_net(pruned_model, full_model, graph):
    '''
    Use graphviz to visualize the results of pruning a network
    pruned_model and full_model are cobrapy objects that you want visualized
    full_graph is a pygraphviz object made using full_model
    '''
    # get a list of all the reaction IDs in the pruned model so that we can see
    # which reactions are in both models (since two reaction objects from 
    # different models are never equal, but their IDs might be)
    pruned_ids = [r.id for r in pruned_model.reactions]
    # now change the colors of the reaction nodes/edges that were pruned
    for rxn in full_model.reactions:
        # identify all the reactions that had flux in the full model (since we
        # only included those in the graphviz object) that weren't in the
        # pruned model
        if rxn.id in graph.nodes() and rxn.id not in pruned_ids:
            # make the node invisible
            rxn_node = graph.get_node(rxn.id)
            rxn_node.attr['color'] = 'invis'
            rxn_node.attr['fontcolor'] = 'invis'
            # change color of all attached edges
            for met in rxn.metabolites:
                # pygraphviz is a little dumb about the ordering of nodes in
                # edges
                try:
                    dropped_edge = graph.get_edge(met.id, rxn.id)
                except KeyError:
                    dropped_edge = graph.get_edge(rxn.id, met.id)
                dropped_edge.attr['color'] = 'invis'
    # now change the colors of the metabolites that are now dropped
    pruned_met_ids = [m.id for m in pruned_model.metabolites]
    for met in full_model.metabolites:
        # once again, make sure the metabolite is in the graph before trying to
        # turn it invisible
        if met.id in graph.nodes() and met.id not in pruned_met_ids:
            met_node = graph.get_node(met.id)
            met_node.attr['color'] = 'invis'
    return(graph)
